import dash
import dash_core_components as dcc
import dash_html_components as html
import pandas as pd
import sys
import os
import statistics
from keras.models import load_model
import numpy as np
from math import sqrt
import numpy as np
from numpy import concatenate
from matplotlib import pyplot
import matplotlib.pyplot as plt
from pandas import read_csv
from pandas import DataFrame
from pandas import concat
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import mean_squared_error
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
import sys
import pandas as pd
import numpy as np
import os
import plotly.express as px
import statistics
import math
from keras.models import load_model
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
np.set_printoptions(threshold=sys.maxsize)




def series_to_supervised(data, n_in=1, n_out=1, dropnan=True):
    n_vars = 1 if type(data) is list else data.shape[1]
    df = DataFrame(data)
    cols, names = list(), list()
    # input sequence (t-n, ... t-1)
    for i in range(n_in, 0, -1):

        cols.append(df.shift(i))
        names += [('var%d(t-%d)' % (j + 1, i)) for j in range(n_vars)]
    # forecast sequence (t, t+1, ... t+n)
    for i in range(0, n_out):

        cols.append(df.shift(-i))
        if i == 0:
            names += [('var%d(t)' % (j + 1)) for j in range(n_vars)]
        else:
            names += [('var%d(t+%d)' % (j + 1, i)) for j in range(n_vars)]
    # put it all together
    agg = concat(cols, axis=1)
    agg.columns = names
    # drop rows with NaN values
    if dropnan:
        agg.dropna(inplace=True)
    return agg
j = 1
list_index = []
for i in range(28,208):
    if(j%4!=0):
        list_index.append(i)
    j+=1
# # load dataset
dataset = pd.read_csv("/var/www/FlaskApp/data/Dec17.csv")
df = pd.read_csv("/var/www/FlaskApp/data/update_data.csv")
# dataset = read_csv('pollution.csv', header=0, index_col=0)
values = dataset.values

# integer encode direction
df.set_index("test_date", inplace = True)
dataset.set_index("Test Date",inplace = True)
encoder = LabelEncoder()
values[:, 0] = encoder.fit_transform(values[:, 0])

# # ensure all data is float
values = values.astype('float32')
# # normalize features
scaler_x = MinMaxScaler(feature_range=(0, 1))
scaler_y = MinMaxScaler(feature_range=(0, 1))
scaled_x = scaler_x.fit_transform(values[:,:3])
scaled_y = scaler_y.fit_transform(values[:,None,-1])
scaled = concatenate((scaled_x,scaled_y),axis = 1)
# # specify the number of lag hours
n_days = 7
n_features = 4
# frame as supervised learning
reframed = series_to_supervised(scaled, n_days, 45)
reframed_copy = reframed.copy()
reframed.drop(reframed.columns[list_index], axis=1, inplace=True)

# split into train and test sets
v = reframed.values
value = v.copy()
n_train_time = int(reframed.shape[0] * 0.8)
train = value[:n_train_time, :]
test = value[n_train_time:, :]
# split into input and outputs
n_obs = n_days * n_features
train_X, train_y = train[:, :n_obs], train[:, -45:]
test_X, test_y = test[:, :n_obs], test[:, -45:]


# # reshape input to be 3D [samples, timesteps, features]
train_x = train_X.reshape((train_X.shape[0], n_days, n_features))
test_x = test_X.reshape((test_X.shape[0], n_days, n_features))
sys.path.insert(0,'/var/www/FlaskApp/FlaskApp')

app = dash.Dash()
model = load_model('/var/www/FlaskApp/FlaskApp/dec_model.h5')
result = []
month_result = []
for i in range(45):
    month_result.append([])
def get_result(inv_yhat, x_days_back):
    global result
    row = 0
    column = 44
    while row < inv_yhat.shape[0] and column < inv_yhat.shape[1]:
        result.append(inv_yhat[row][column])
        row+=1
        column-=1

def get_monthly_result(inv_yhat, x_days_back):
    global month_result
    prediction_date = 0
    while(prediction_date < 45 - x_days_back):
        row = prediction_date
        column = 44
        while row < inv_yhat.shape[0] and column < inv_yhat.shape[1]:
            month_result[prediction_date].append(inv_yhat[row][column])
            row+=1
            column-=1
        prediction_date+=1
def prediction(local_reframe, x_days_back):
    row_restriction = local_reframe.shape[0]-45+x_days_back
    column_restriction  =local_reframe.shape[1]-x_days_back*4
    test_data = local_reframe.iloc[row_restriction:,column_restriction-28:column_restriction].values
    yhat = model.predict(test_data.reshape((test_data.shape[0], n_days, n_features)))
    inv_yhat = scaler_y.inverse_transform(yhat)
    get_monthly_result(inv_yhat, x_days_back)
    get_result(inv_yhat,x_days_back)

for i in range(0,45):
    prediction(reframed_copy, i)
fig =px.line(dataset, x = dataset.index, y = 'Death Cases')
real_death = int(df.iloc[dataset.shape[0]]['Death Cases'])
data = []
median_death = []
day_x = []
count = 0
for i in month_result:
    data.append({'x' : count, 'y' : i, 'type'  :'box', 'name' : str(count+1) + " day(s) after December 17th"})
    median_death.append(statistics.median(i))
    day_x.append(count)
    count+=1
real_45_day_death = []
real_45_day_death_x = []
count = 0
for i in range(dataset.shape[0], dataset.shape[0]+45):
    real_45_day_death.append(int(df.iloc[i]['Death Cases']))
    real_45_day_death_x.append((count))
# data.append({'x' :real_45_day_death_x , 'y' : real_45_day_death, 'type'  :'linear', 'name' :   "45 days after Dec 17th"})
result_df = pd.DataFrame(result, columns = ['predicted death'])
result_x = ['dec 18' for i in range(len(result))]
result_df['date'] = result_x

single_prediction_fig = px.box(result_df, x="date", y="predicted death", points="all", name = 'predicction')
single_prediction_fig.append_trace({'x' : 'dec 18', 'y' : [real_death], 'type': 'linear', 'name' : 'Dec 18th real death cases'})
app.layout = html.Div(children=[
    html.Div([html.H1(children='Dash Tutorials'),
    dcc.Graph(id='example',figure= fig)
    ]),
    html.Div(children = [html.H2(children = 'December 18th Death Cases'),
    dcc.Graph(id = 'Dec 18 predict death', figure = single_prediction_fig),
    dcc.Graph(id = '45 day boxplot', figure = {'data':data}),
    dcc.Graph(id = 'medain of 45 day', figure = {'data':[{'x':day_x, 'y': median_death, 'type' :'linear', 'name':'median of death for future 45 day'},{'x' :day_x , 'y' : real_45_day_death, 'type'  :'linear', 'name' :   "45 days after Dec 17th"}]})
 ]),
])
server = app.server
if __name__ == '__main__':
    app.run_server(debug=True)
